import { connect as e } from "cloudflare:sockets";
const t = "1f9d104e-ca0e-4202-ba4b-a0afb969c747";
let r = [
  "bestproxy.030101.xyz:443",
  atob("cHJveHlpcC5hbWNsdWJzLmNhbWR2ci5vcmc="),
  atob("cHJveHlpcC5hbWNsdWJzLmtvem93LmNvbQ=="),
  ...[
    {
      domain: "ProxyIP.US.CMLiussss.net",
      region: "US",
      regionCode: "US",
      port: 443,
    },
    {
      domain: "ProxyIP.SG.CMLiussss.net",
      region: "SG",
      regionCode: "SG",
      port: 443,
    },
    {
      domain: "ProxyIP.JP.CMLiussss.net",
      region: "JP",
      regionCode: "JP",
      port: 443,
    },
    {
      domain: "ProxyIP.HK.CMLiussss.net",
      region: "HK",
      regionCode: "HK",
      port: 443,
    },
    {
      domain: "ProxyIP.KR.CMLiussss.net",
      region: "KR",
      regionCode: "KR",
      port: 443,
    },
    {
      domain: "ProxyIP.DE.CMLiussss.net",
      region: "DE",
      regionCode: "DE",
      port: 443,
    },
    {
      domain: "ProxyIP.SE.CMLiussss.net",
      region: "SE",
      regionCode: "SE",
      port: 443,
    },
    {
      domain: "ProxyIP.NL.CMLiussss.net",
      region: "NL",
      regionCode: "NL",
      port: 443,
    },
    {
      domain: "ProxyIP.FI.CMLiussss.net",
      region: "FI",
      regionCode: "FI",
      port: 443,
    },
    {
      domain: "ProxyIP.GB.CMLiussss.net",
      region: "GB",
      regionCode: "GB",
      port: 443,
    },
    {
      domain: "ProxyIP.Oracle.cmliussss.net",
      region: "Oracle",
      regionCode: "Oracle",
      port: 443,
    },
    {
      domain: "ProxyIP.DigitalOcean.CMLiussss.net",
      region: "DigitalOcean",
      regionCode: "DigitalOcean",
      port: 443,
    },
    {
      domain: "ProxyIP.Vultr.CMLiussss.net",
      region: "Vultr",
      regionCode: "Vultr",
      port: 443,
    },
    {
      domain: "ProxyIP.Multacom.CMLiussss.net",
      region: "Multacom",
      regionCode: "Multacom",
      port: 443,
    },
  ].map((e) => `${e.domain}:${e.port}`),
];
const n = r[Math.floor(Math.random() * r.length)],
  o = [
    "bestcf.030101.xyz:443",
    "japan.com:443",
    "www.visa.com.sg:443",
    "www.visa.com.hk:443",
    "icook.hk:443",
    "icook.tw:443",
  ];
var a = {
  async fetch(r) {
    const a = new URL(r.url);
    if ("websocket" === r.headers.get("Upgrade")?.toLowerCase())
      return await (async function (r) {
        const [o, a] = Object.values(new WebSocketPair());
        a.accept();
        const c = new URL(r.url);
        if (c.pathname.includes("%3F")) {
          const e = decodeURIComponent(c.pathname),
            t = e.indexOf("?");
          -1 !== t &&
            ((c.search = e.substring(t)), (c.pathname = e.substring(0, t)));
        }
        const d = c.searchParams.get("mode") || "proxy",
          l = c.searchParams.get("s5"),
          p = c.searchParams.get("proxyip"),
          u = l || c.pathname.slice(1),
          w = u.includes("@")
            ? (() => {
                const [e, t] = u.split("@"),
                  [r, n] = e.split(":"),
                  [o, a = 443] = t.split(":");
                return { user: r, pass: n, host: o, port: +a };
              })()
            : null,
          h = p ? String(p) : n,
          g = () => {
            if ("proxy" === d) return ["direct", "proxy"];
            if ("auto" !== d) return [d];
            const e = [],
              t = c.search.slice(1);
            for (const r of t.split("&")) {
              const t = r.split("=")[0];
              "direct" === t
                ? e.push("direct")
                : "s5" === t
                  ? e.push("s5")
                  : "proxyip" === t
                    ? e.push("proxy")
                    : "nat64" === t && e.push("nat64");
            }
            return e.length ? e : ["direct"];
          };
        let m = null,
          f = null,
          y = !1;
        const b = async (t, r) => {
          const n = e({ hostname: w.host, port: w.port });
          await n.opened;
          const o = n.writable.getWriter(),
            a = n.readable.getReader();
          await o.write(new Uint8Array([5, 2, 0, 2]));
          if (2 === (await a.read()).value[1] && w.user) {
            const e = new TextEncoder().encode(w.user),
              t = new TextEncoder().encode(w.pass);
            (await o.write(new Uint8Array([1, e.length, ...e, t.length, ...t])),
              await a.read());
          }
          const s = new TextEncoder().encode(t);
          return (
            await o.write(
              new Uint8Array([5, 1, 0, 3, s.length, ...s, r >> 8, 255 & r]),
            ),
            await a.read(),
            o.releaseLock(),
            a.releaseLock(),
            n
          );
        };
        return (
          new ReadableStream({
            start(e) {
              (a.addEventListener("message", (t) => e.enqueue(t.data)),
                a.addEventListener("close", () => {
                  (m?.close(), e.close());
                }),
                a.addEventListener("error", () => {
                  (m?.close(), e.error());
                }));
              const t = r.headers.get("sec-websocket-protocol");
              if (t)
                try {
                  e.enqueue(
                    Uint8Array.from(
                      atob(t.replace(/-/g, "+").replace(/_/g, "/")),
                      (e) => e.charCodeAt(0),
                    ).buffer,
                  );
                } catch {}
            },
          })
            .pipeTo(
              new WritableStream({
                async write(r) {
                  if (y) return f?.write(r);
                  if (m) {
                    const e = m.writable.getWriter();
                    return (await e.write(r), void e.releaseLock());
                  }
                  if (r.byteLength < 24) return;
                  const n = new Uint8Array(r.slice(1, 17)),
                    o = t.replace(/-/g, "");
                  for (let e = 0; e < 16; e++)
                    if (n[e] !== parseInt(o.substr(2 * e, 2), 16)) return;
                  const c = new DataView(r),
                    d = c.getUint8(17),
                    l = c.getUint8(18 + d);
                  if (1 !== l && 2 !== l) return;
                  let p = 19 + d;
                  const u = c.getUint16(p),
                    C = c.getUint8(p + 2);
                  p += 3;
                  let P = "";
                  if (1 === C)
                    ((P = `${c.getUint8(p)}.${c.getUint8(p + 1)}.${c.getUint8(p + 2)}.${c.getUint8(p + 3)}`),
                      (p += 4));
                  else if (2 === C) {
                    const e = c.getUint8(p++);
                    ((P = new TextDecoder().decode(r.slice(p, p + e))),
                      (p += e));
                  } else {
                    if (3 !== C) return;
                    {
                      const e = [];
                      for (let t = 0; t < 8; t++, p += 2)
                        e.push(c.getUint16(p).toString(16));
                      P = e.join(":");
                    }
                  }
                  const L = new Uint8Array([r[0], 0]),
                    x = r.slice(p);
                  if (2 === l) {
                    if (53 !== u) return;
                    y = !0;
                    let e = !1;
                    const { readable: t, writable: r } = new TransformStream({
                      transform(e, t) {
                        for (let r = 0; r < e.byteLength; ) {
                          const n = new DataView(e.slice(r, r + 2)).getUint16(
                            0,
                          );
                          (t.enqueue(e.slice(r + 2, r + 2 + n)), (r += 2 + n));
                        }
                      },
                    });
                    return (
                      t.pipeTo(
                        new WritableStream({
                          async write(t) {
                            try {
                              const r = await fetch(
                                "https://1.1.1.1/dns-query",
                                {
                                  method: "POST",
                                  headers: {
                                    "content-type": "application/dns-message",
                                  },
                                  body: t,
                                },
                              );
                              if (1 === a.readyState) {
                                const t = new Uint8Array(await r.arrayBuffer());
                                (a.send(
                                  new Uint8Array([
                                    ...(e ? [] : L),
                                    t.length >> 8,
                                    255 & t.length,
                                    ...t,
                                  ]),
                                ),
                                  (e = !0));
                              }
                            } catch {}
                          },
                        }),
                      ),
                      (f = r.getWriter()),
                      f.write(x)
                    );
                  }
                  let U = null;
                  for (const t of g())
                    try {
                      if ("direct" === t) {
                        ((U = e({ hostname: P, port: u })), await U.opened);
                        break;
                      }
                      if ("s5" === t && w) {
                        U = await b(P, u);
                        break;
                      }
                      if ("proxy" === t && h) {
                        const [t, r = u] = h.split(":");
                        ((U = e({ hostname: t, port: +r || u })),
                          await U.opened);
                        break;
                      }
                      if ("nat64" === t) {
                        let t = P;
                        (2 === C ? (t = await i(P)) : 1 === C && (t = s(P)),
                          (U = e({ hostname: t, port: u })),
                          await U.opened);
                        break;
                      }
                    } catch {}
                  if (!U) return;
                  m = U;
                  const S = U.writable.getWriter();
                  (await S.write(x), S.releaseLock());
                  let I = !1;
                  U.readable
                    .pipeTo(
                      new WritableStream({
                        write(e) {
                          1 === a.readyState &&
                            (a.send(
                              I
                                ? e
                                : new Uint8Array([...L, ...new Uint8Array(e)]),
                            ),
                            (I = !0));
                        },
                        close: () => 1 === a.readyState && a.close(),
                        abort: () => 1 === a.readyState && a.close(),
                      }),
                    )
                    .catch(() => {});
                },
              }),
            )
            .catch(() => {}),
          new Response(null, { status: 101, webSocket: o })
        );
      })(r);
    if ("GET" === r.method) {
      if ("/" === a.pathname) {
        return new Response("<h1>success</h1>", {
          status: 200,
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
      if (a.pathname.toLowerCase().includes(`/${t}`))
        return await (async function (e) {
          const r = new URL(e.url);
          let n = (function (e) {
              let r = [],
                n = 0;
              const a = encodeURIComponent("/?ed=2048"),
                s = atob("dmxlc3M=");
              return (
                o.forEach((o) => {
                  n += 1;
                  let i = "snippet_" + n;
                  const c = new URLSearchParams({
                    encryption: "none",
                    security: "tls",
                    sni: e,
                    fp: "chrome",
                    type: "ws",
                    host: e,
                    path: a,
                  });
                  r.push(
                    `${s}://${t}@${o}?${c.toString()}#${encodeURIComponent(i)}`,
                  );
                }),
                r
              );
            })(r.hostname),
            a = btoa(n.join("\n"));
          return new Response(a, {
            headers: {
              "Content-Type": "text/plain; charset=utf-8",
              "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
            },
          });
        })(r);
    }
    return new Response("error", { status: 404 });
  },
};
function s(e) {
  const t = e.trim().split(".");
  if (4 !== t.length) throw new Error("Invalid IPv4 address");
  const r = t.map((e) => {
    const t = Number(e);
    if (!/^\d+$/.test(e) || isNaN(t) || t < 0 || t > 255)
      throw new Error(`Invalid IPv4 segment: ${e}`);
    return t.toString(16).padStart(2, "0");
  });
  return `[${`2602:fc59:b0:64::${`${r[0]}${r[1]}:${r[2]}${r[3]}`.toLowerCase()}`}]`;
}
async function i(e) {
  try {
    const t = await fetch(`https://1.1.1.1/dns-query?name=${e}&type=A`, {
      headers: { Accept: "application/dns-json" },
    });
    if (!t.ok)
      throw new Error(`DNS query failed with status code: ${t.status}`);
    const r = await t.json(),
      n = r?.Answer?.find((e) => 1 === e.type && e.data);
    if (!n) throw new Error("No valid A record found");
    const o = n.data;
    return s(o);
  } catch (e) {
    throw new Error(`Domain resolution failed: ${e.message}`);
  }
}
export { a as default };
